"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const endpoint = "https://api.scryfall.com";
const rateLimit = 100;
let lastQuery = 0;
function sleep(ms = 0) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
class MagicQuerier {
    query(apiPath, query, post) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(apiPath)) {
                apiPath = apiPath.join("/");
            }
            let lastError;
            let result;
            for (let i = 0; i < MagicQuerier.retry.attempts; i++) {
                ({ result, lastError } = yield this.tryQuery(`${apiPath}`, query, post));
                if (result || !this.canRetry(lastError))
                    break;
                yield sleep(MagicQuerier.retry.timeout);
            }
            MagicQuerier.lastError = lastError;
            return result ? result.data : { data: [] };
        });
    }
    queryPage(emitter, apiPath, query, page = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield this.query(apiPath, Object.assign({}, query, { page }));
            for (const card of results.data) {
                if (emitter.cancelled)
                    break;
                emitter.emit("data", card);
            }
            if (results.has_more) {
                if (!emitter.cancelled) {
                    if (emitter.willCancelAfterPage)
                        emitter.cancel();
                    else
                        return this.queryPage(emitter, apiPath, query, page + 1)
                            .catch(err => { emitter.emit("error", err); });
                }
            }
            if (!emitter.cancelled)
                emitter.emit("end");
            emitter.emit("done");
        });
    }
    tryQuery(apiPath, query, post) {
        return __awaiter(this, void 0, void 0, function* () {
            const now = Date.now();
            const timeSinceLastQuery = now - lastQuery;
            if (timeSinceLastQuery >= rateLimit) {
                lastQuery = now;
            }
            else {
                const timeUntilNextQuery = rateLimit - timeSinceLastQuery;
                lastQuery += timeUntilNextQuery;
                yield sleep(timeUntilNextQuery);
            }
            let lastError;
            const result = (yield axios_1.default.request({
                data: post,
                method: post ? "POST" : "GET",
                params: query,
                url: `${endpoint}/${apiPath}`,
            }).catch(({ response }) => {
                lastError = response.data;
            })) || undefined;
            return { result, lastError };
        });
    }
    canRetry(error) {
        if (error.code == "not_found" || error.code == "bad_request")
            return false;
        return !MagicQuerier.retry.canRetry || MagicQuerier.retry.canRetry(error);
    }
}
MagicQuerier.lastQuery = 0;
MagicQuerier.retry = { attempts: 1 };
exports.default = MagicQuerier;
